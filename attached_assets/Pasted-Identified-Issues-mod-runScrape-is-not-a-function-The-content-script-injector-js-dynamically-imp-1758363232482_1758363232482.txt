Identified Issues

mod.runScrape is not a function: The content script (injector.js) dynamically imports content/scraper.js and calls mod.runScrape(...), but the module does not export runScrape, so mod.runScrape is undefined. In the compiled code we see import(chrome.runtime.getURL('content/scraper.js')).then(mod => mod.runScrape(...)), but scraper.js defines async function runScrape without exporting it. Fix: Convert scraper.js into a proper ES module (e.g. add export { runScrape }) or use chrome.scripting.executeScript() with a function injection to call runScrape in-page. Ensuring static exports will align with MV3’s restrictions on script injection.

CSP Violations & eval() Usage: The console log shows errors like “Refused to connect to <URL>… violates default-src 'self'” and rejection of inline or eval scripts. Manifest V3’s CSP forbids eval/new Function and any remotely-hosted scripts
developer.chrome.com
stackoverflow.com
. For example, extension pages must use only script-src 'self' and cannot use unsafe-eval
stackoverflow.com
. All code must be bundled (no loading external JS at runtime)
developer.chrome.com
. Fix: Remove any eval or dynamic scriptTag.innerHTML calls; instead use script.src = chrome.runtime.getURL(...) to inject trusted scripts
stackoverflow.com
. Declare all needed host permissions ("permissions" and "host_permissions") so network requests use allowed targets, or perform fetches in the service worker with proper fetch() calls. Update the manifest content_security_policy to the MV3 format (extension_pages and sandbox) and eliminate forbidden directives
developer.chrome.com
stackoverflow.com
.

Smart Selector Mode Bug (Click Navigation): The “Element Picker” overlay must intercept clicks so that clicking an image does not navigate away. The provided picker.js implements this by adding high-priority listeners that call event.preventDefault()/stopPropagation() on clicks and even on mousedown/up events. However, the existing build shows users were being navigated away. This suggests the picker may not have been loaded or initialized. Fix: Ensure the enhanced picker (StepTwoElementPicker) is always used and initialized when selector mode is triggered. Its preventNavigation handler (shown in [51]) must be attached so all clicks are intercepted. Verify that startPicker() is actually called (from content/picker.js) and that its preventDefaultClicks option is active (it is true by default) to stop image clicks from performing navigation.

UI/UX Confusion (Popup vs “Pop-out”): The extension currently has two interface modes – a compact popup and a separate “windowed dashboard” – which confuse users. For example, the popup’s buttons (quick scan, full scan, open dashboard) and the separate dashboard window overlap in functionality. Fix: Consolidate into a single coherent workflow. Possible approaches:

Unified Dashboard Only: Eliminate the separate popup and always open a dedicated window or panel for scanning (as per MV3 “action.popup” or use chrome.windows.create). Clearly label buttons (e.g. “Open Scraper Dashboard” vs “Scan Now”).

Popup-Focused: Keep a simplified popup UI (e.g. “Quick Scan” button and status display) and use one button (“Open Full Dashboard”) to launch the advanced interface. Remove redundant “pop-out” terminology.
In either case, revise labels/tooltips so that each control’s effect is obvious (e.g. “Scan current gallery” vs “Switch to selection mode”). Provide clear instructions or icons (for example, a separate “picker” icon for selector mode) and avoid two equally-named modes.

2. UX & Workflow Redesign

Triggering Scans: Simplify to one or two obvious actions. For example, have a single “Scan Gallery” button in the popup; if the page is auto-detected as a gallery, it immediately begins scraping, else it offers the user manual selector mode. Display real-time status (number of images found, pages scanned) in the popup.

Button/Mode Clarity: Use descriptive text/icons. E.g. rename “Pop Out” to “Open Dashboard” or “Advanced Options”. Clearly separate “Quick Scan” (counts images) from “Full Scrape” actions.

Single Interface Flow: If using only the popup, ensure it can remain open (or auto-reopen) during long scrapes. Otherwise, if a separate window is used, prompt the user (via the popup) to switch to it. Always reflect current tab/page status (gallery vs not) in the UI.

Selector Mode Access: Provide a toggle (e.g. a crosshair icon) labelled “Select Images” that, when clicked, closes the popup (so the page is interactable) and activates the element picker overlay (as in picker.js). Show instructions (“Click an image to select all similar items, Esc to cancel”).

Feedback and Errors: Clearly surface any issues (e.g. “No images found” or “CSP blocked request”) in the UI so users know if the scrape failed.

3. Scraping Logic Enhancements

Auto-detect Galleries: Leverage and refine injector.js’s detectGalleryPage() logic. Currently it checks image count, title/URL keywords, CSS selectors, etc. Improve by adding more patterns (e.g. common gallery page markers) and caching results (as it does).

Manual vs Automatic Activation: Allow manual start (via UI) and optionally auto-start if a gallery is detected. For example, on page load the content script can run a quick heuristic (≤2 sec delay) and, if isGalleryPage, enable the “Scan” button or even auto-click it. This requires coordination between the content script and popup (e.g. using chrome.runtime.sendMessage with page status). The existing maybeAuto() and autoStartScraping() in injector.js hint at this flow. Ensure autoDetect setting can toggle this behavior.

Domain-agnostic Support: Build or refine a site-profile system. The extension already contains a profiles list for known domains with custom selectors. Expand this list or let advanced users define new profiles. For unknown domains, rely on generic logic (default container selector or simple img tags).

Pagination & Infinite Scroll: Maintain and improve logic to traverse multi-page galleries:

Click “Next” Buttons: The code’s handlePagination() already looks for “next page” buttons by common selectors (aria-labels, rel="next", classes). Enhance it by adding site-specific selectors if needed.

Infinite Scroll: The code’s handleInfiniteScroll() loop scrolls and waits for new images. Ensure it breaks after a sensible timeout or if no new content, to avoid endless loops. Fine-tune the exit conditions (e.g. maximum total time from settings).

State Persistence: If the user navigates (clicks) to the next page manually or if the extension clicks “Next,” the scraper should continue collecting in the new page. The current design handles both in one runScrape call. For more robustness, the background script could aggregate images across multiple SCRAPE_DONE messages if scrapes happen in segments. Alternatively, detect history changes and auto-invoke scraping again.

Large Galleries & Memory: Utilize the MemoryOptimizedProcessor (already present) for huge galleries (thousands of images) to avoid blocking or crashing. Ensure it’s initialized (initializeMemoryProcessor) based on estimated gallery size. Allow exporting large result sets (using the advanced exporter) without freezing the browser.

4. Manifest V3 Compliance and Security

Eliminate Dynamic Code Execution: Manifest V3 forbids eval(), new Function(), and dynamic script injection except via approved methods
stackoverflow.com
developer.chrome.com
. For example, remove any code that tries to inject inline scripts or evaluate strings. Instead, use the MV3-approved APIs: chrome.scripting.executeScript({ func: someFunction }) or static content scripts. The Chrome docs explicitly state “you can no longer execute external logic using executeScript(), eval(), and new Function()”
developer.chrome.com
.

Bundle All Resources: All JavaScript, CSS, WASM, etc., must be packaged with the extension
developer.chrome.com
. Do not load code from remote URLs at runtime. For instance, libraries (Vue.js, PapaParse, etc.) should be included locally (as they already are) and referenced from extension files. The manifest already lists web_accessible_resources for needed scripts, which is correct; just ensure no code calls external servers for scripts.

Update CSP Policy: In manifest.json, use the MV3 content_security_policy format with "extension_pages" and optional "sandbox". For example:

"content_security_policy": {
  "extension_pages": "script-src 'self'; object-src 'self'",
  "sandbox": "sandbox allow-scripts; script-src 'self'; object-src 'self'"
}


This ensures only bundled scripts/styles run. Remove any 'unsafe-eval' or inline script allowances (MV3 disallows them)
stackoverflow.com
developer.chrome.com
.

Permissions Model:

Action Pages: The extension’s popup and dashboard UI are “extension pages” with protocol chrome-extension://. They are governed by the extension_pages CSP above.

Background Service Worker: The background script should run as a service worker (already declared) and use importScripts() or static imports. If using ES modules, set "background": {"service_worker": "background.js", "type": "module"} in manifest. This enables import statements.

Host Permissions: Declare in permissions or host_permissions any domains from which you fetch (e.g. image servers, APIs). This will resolve CSP “connect-src” issues. By default, MV3 extensions need explicit host permissions for cross-origin XHR/fetch.

Avoid Unsafe Script Sources: All scripts must be either in manifest.json or in listed web_accessible_resources. The CSP should not need hashes since we avoid inline code. Use chrome.runtime.getURL() to reference any script or resource at runtime (as seen in the code)
stackoverflow.com
.

5. Proposed Architecture & Modules
Module / File	Purpose	Issues / Notes	Fix / Action Item
content/injector.js	Detects galleries, handles messages from UI, loads modules dynamically.	Uses dynamic import(...) to load other scripts; auto-start logic.	Ensure dynamic imports only load bundled modules. After fixing scraper.js exports, injector.js can import() it normally. Simplify by using chrome.scripting.executeScript() for some actions if needed (e.g. start scraper). Keep detectGalleryPage() updated with heuristics.
content/scraper.js	Core scraping logic: find images, apply filters, pagination/infinite scroll, send results.	Defined runScrape but did not export it. Uses DOM APIs and chrome.runtime.sendMessage.	Make scraper.js an ES module by adding export async function runScrape(...) { ... }. This allows import() to work. Alternatively, move runScrape invocation into the background (via chrome.scripting.executeScript({ func: runScrape, args: [...]})). Verify pagination/infinite logic as outlined above.
content/picker.js	Element selection overlay (smart selector). Prevents default clicks.	Already addresses click/navigation issues (see [51]). Might not load if not triggered correctly.	Confirm that whenever “selector mode” is activated, this module is loaded and StepTwoElementPicker.start() is called. Use its preventNavigation to fix the click issue. Test the picker thoroughly across pages.
content/smartGuess.js et al.	(Several enhanced modules like dynamic-content-observer.js, etc.) These aid complex scraping (AI-based patterns, etc.).	Lazy-loaded by injector.js. Ensure they do not rely on banned features.	Audit each enhanced script for CSP compliance (no eval). Since they are local files, loading them via import() is fine. Ensure that heavy processing (e.g. image analysis) is done in web workers or in small batches to avoid blocking the UI.
background/service-worker.js	Receives SCRAPE_DONE, manages downloads/export, context menu, alarms, etc.	Must be an MV3 service worker (no DOM). If it's large, consider splitting to modules.	Declare "background.type": "module" to allow ES6 imports of utility modules. Use chrome.storage or IndexedDB to store state if needed (since service workers can be terminated). Avoid long-running loops; offload tasks to other APIs if needed.
ui/popup.html / popup.js	Browser action popup interface. Shows status, triggers scans, opens dashboard, etc.	Two modes (“popup” vs “windowed”) exist. Some asynchronous messaging with content script.	Refactor to a single consistent popup UI or replace it with a persistent window UI. Ensure popup script is bundled (no inline handlers) and matches CSP. Simplify the flow: e.g. on popup load, query page status (chrome.tabs.sendMessage('getPageStatus')), then enable buttons accordingly.
ui/windowed-dashboard.html/js	A full-page dashboard (opened via popup). Displays progress, results, settings, etc.	Some features duplicate popup. Optional.	Either merge dashboard content into a single UI (maybe as an “options page”) or retire it. If kept, ensure its scripts abide by MV3 CSP. Possibly replace it with a chrome-extension:// page triggered by chrome.windows.create({ url: ... }).
manifest.json	Declares extension metadata, scripts, permissions, CSP.	Currently includes a long inline CSP with hashes (for extension pages). Needs MV3 update.	Update structure to the two-key CSP (extension_pages and sandbox)
developer.chrome.com
. Remove any unsafe-inline/unsafe-eval keywords. Add any missing host permissions (e.g. "https://*/*") under "permissions" or "host_permissions". Ensure all scripts referenced exist in web_accessible_resources for content scripts.

(Table: key modules, roles, and fix actions.)

6. Implementation Plan (Action Items)

Refactor scraper.js and imports:

Edit content/scraper.js to export its functions (e.g. export { runScrape }). Ensure all helper functions it uses are either internal or also exported/imported properly.

Update injector.js calls from import(...).then(mod => mod.runScrape(...)) to use the now-exported function. Alternatively, use chrome.scripting.executeScript with a defined function if better suited.

Resolve CSP/Eval Errors:

Remove any use of eval(), new Function(), or in-page script tags built via .innerHTML. Instead, use chrome.runtime.getURL + script.src injection (per [15])
stackoverflow.com
.

Verify the manifest has no unsafe-inline or unsafe-eval. Move any inline <script> code into .js files.

Check for any blocked network calls; if extension needs to connect (e.g. to download images or configs), ensure permissions and CSP allow it or move to background fetch.

Fix Smart Selector Behavior:

Ensure content/picker.js is loaded when selector mode is activated. In the popup handler for “Enable Selector Mode” (in popup.js), call chrome.tabs.sendMessage({ type: 'START_PICKER' }), which should trigger the START_PICKER case in injector.js (as seen around [26]). That should load picker.js if not loaded, and call window.startPicker.

Verify StepTwoElementPicker is initialized with preventDefaultClicks: true (it is by default) so the attachEventListeners() block (which includes document.addEventListener('mousedown', preventNavigation, true)) runs. Test by enabling selector mode and clicking an image: no navigation should occur.

Redesign UI Flow:

Unify or Remove Modes: Decide on single interface. For example, use only the popup: merge the dashboard UI into the popup (using tabs or sections), or always pop open the dashboard window when scanning.

Label Buttons Clearly: E.g. “Scan Page for Images”, “Open Advanced Dashboard”, “Options” etc. Remove any duplicate buttons.

Clear Feedback: After fixes, have the popup request page status (getPageStatus message) to show “Ready” or “Gallery detected (XX items)”. Provide tooltips or small help text if needed.

Update popup.js and windowed-dashboard.js accordingly, and test that transitions (popup→dashboard, enabling selector, etc.) work seamlessly.

Enhance Scraping Logic:

Gallery Detection: Refine the array of indicator functions in injector.js.detectGalleryPage(). Add any missing heuristics (e.g. check for common gallery DOM structures). Test on a variety of gallery and non-gallery pages to avoid false positives/negatives.

Profiles and Settings: Update or expand the profiles list for popular sites (the JSON block around [18]). Ensure each profile’s selectors and scroll settings are correct.

Pagination/Scroll: Review handlePagination() and handleInfiniteScroll() implementations for edge cases. Add logging to confirm multi-page scraping is working (e.g. see status messages in the UI).

Error Recovery: Make sure all major operations (page load, image extraction, downloads) are wrapped in try/catch or use “withErrorRecovery” so that one failure doesn’t abort the whole scrape.

Manifest V3 & Background Worker:

Add "background.type": "module" if using ES modules in the service worker. Update background scripts to use import instead of old importScripts, if any.

Test the service worker’s message handling (chrome.runtime.onMessage) works for both popup and content script messages.

Verify any chrome.tabs or chrome.windows API use is correct (e.g. opening the dashboard window from the popup).

Check extension behavior on Chrome 104+ and ensure no errors (e.g. missing window in worker context).

Testing & Verification:

Functionality Tests: On sample sites (e.g. Instagram gallery, Flickr album, e-commerce product grid), verify:

Detect gallery correctly (UI shows “Gallery page”).

Full scan collects all image URLs (compare count manually).

Next page / infinite scroll images are included.

Filters (size, duplicates) work as expected.

Selector mode selects intended elements without navigation.

Permission/CSP Checks: Ensure no console CSP errors remain. Test requests (e.g. image blob download) are allowed.

Cross-Domain: Try on pages from different domains to confirm “any domain” support.

UI/UX: Walk through UI flows for new/naïve user: installation→open popup→scan→export. Record any confusion.

7. Documentation and QA

Function Documentation:
For every module and function, add clear JSDoc or inline comments. Example format:

/**
 * Scans the page for images matching the given selector,
 * collects metadata, handles pagination/infinite scroll,
 * and sends results to the background.
 * @param {string} selector - CSS selector for image container elements.
 * @param {object} options - Scraper options (e.g. siteProfile, scroll settings).
 */
async function runScrape(selector, options = {}) { ... }


Document parameters, return values (or callbacks), and exceptions. A table can summarize key functions:

Function	Purpose	Inputs	Outputs/Effects
detectGalleryPage()	Heuristic check if current page is an image gallery.	– (uses document context)	Returns true/false; sets isGalleryPage.
runScrape(selector, options)	Main image extraction workflow (see above).	selector (string), options (object)	Sends SCRAPE_DONE with results.
handlePagination(collectFn, nextSelector)	Clicks “next page” links and calls collectFn per page.	collectFn (async function), nextSelector (CSS)	Visits pages up to limit or no-button.
start() (in picker)	Activates element picker overlay on the page.	siteProfile (object, optional)	Listens for user click to select elements.
…and so on…			

(More functions like loadSettings(), initializeMemoryProcessor(), etc., should be similarly described.)

UX Flow Documentation:
Create a flowchart or bullet outline of user interactions. For example:

Page Load: injector.js runs, detects if the page looks like a gallery.

Popup Open: On clicking the extension icon, popup.js queries the content script (getPageStatus). It then displays “Gallery page (X images)” or “Ready to scan”.

User Action:

If Quick Scan is clicked, content script counts images and updates status.

If Full Scan is clicked, content script calls runScrape (with optional siteProfile).

If Select Images is clicked, popup closes and startPicker() is invoked; user selects elements, then popup can re-open automatically to scrape.

If Open Dashboard is clicked, a new window opens showing progress (and popup closes).

Scraping: runScrape collects images (using filters), paginates/infinite scrolls as needed, and sends back results.

Completion: The UI (popup or dashboard) shows “Scraping complete” and offers export options (CSV, JSON, or start download queue).
Document also edge cases, e.g. what happens if the user navigates away mid-scrape (likely cancel), or if no images found.

Bug Checklist & Verification:

 runScrape Error Fixed: No console errors about runScrape. Test that SCRAPE_DONE messages arrive with items.

 CSP Compliance: No “Refused to execute” or “Refused to connect” errors in console. (All inline scripts and evals removed.)

 Smart Selector Works: In selector mode, clicking images selects them (outline/highlight) and does not navigate away.

 UI Consistency: “Popup” and “Dashboard” show consistent state and do not duplicate. Buttons perform only the described action.

 Auto-Detect Behavior: On known gallery pages, the extension indicates “Gallery detected” without manual trigger.

 Cross-Site Test: Verify on at least three different gallery sites (e.g., Unsplash, Flickr, an e-commerce site) to ensure selectors handle diverse DOMs.

 Permissions and Hosts: Attempt a fetch/XHR to an external URL (within declared permissions) to confirm no CSP blocking.

 MV3 Requirements: Load the packed extension (in Chrome 104+) and confirm no MV2 warnings. Check manifest keys (background.type: module, content_security_policy object, etc.).

 Performance: Test a very large gallery (e.g. 1000+ images) to see that the UI remains responsive (courtesy of memory optimization and batching).

Each item should be verified on both development (console logs) and end-user builds (packed extension). Any failures should be fixed iteratively.